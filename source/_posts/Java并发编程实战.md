---
title: Java并发编程实战
top: true
date: 2019-07-08 17:28:08
tags: Java Concurrent
toc: true
categories:
  - Java Concurrent
thumbnail: https://tvax1.sinaimg.cn/large/005BYqpggy1g4mghnm1y2j30sg0lcaan.jpg
---

## 线程相关概念

### 进程

_进程是操作系统中最重要的抽象概念之一,是系统进行资源分配和调度的基本单位,也是线程的容器_

---

### 线程

_线程是操作系统能够进行运算的最小单位,被包含在进程之中,是进程实际运作单位,又称为轻量级进程_

Q: 多线程会更快吗?

A: 并发执行有时会因为上下文切换和资源调度的问题,导致执行速度没有串行快

---

### 并发和并行

- 并行: 并行是指两个或者多个事件在同一时刻发.
- 并发: 并发是指两个或多个事件在同一时间间隔内发生

  !["并发和并行图解"](https://i.loli.net/2019/07/08/5d230eaa3a24b16538.png)

  👉👉*<font color="red">并行是两个队伍分别使用一台咖啡机,并发是两个队伍依次轮流使用一台咖啡机.</font>*

<!-- more -->

---

### 线程的安全性

- 当`多个线程访问某个类`的时候,这个类始终都能表现出正确的行为,说明这个类是线程安全的

- 无状态对象(不包含域&也不包含其他类中域的引用)是线程安全的

---

### 竞态条件&数据竞争

- 竞态条件: 由于不恰当的执行时序而出现不正确的结果,最常见的一种竞态类型是: 先检查后执行. 通过一个可能失效的观测结果来决定下一步动作

- 数据竞争: 如果在访问共享的非 final 类型的域时没有采用同步来进行协同就会出现数据竞争

---

### Synchronized

> <a href="../Synchronized锁详解">Synchronized 锁详解</a>

### 死锁

- 代码展示

```java
public class DeadLock {

    private static final String A = "A";
    private static final String B = "B";

    private void deadLock() {
        Thread t1 = new Thread(() -> {
            synchronized (A) {
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (B) {
                    System.out.println("Get Lock B");
                }
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (B) {
                synchronized (A) {
                    System.out.println("Get Lock A");
                }
            }
        });

        t1.start();
        t2.start();
    }

    public static void main(String[] args) {
        new DeadLock().deadLock();
    }
}
```

- 使用 jconsole 查看线程

  _Thread-0 和 Thread-1 分别都 Blocked 了,都在等待对方释放锁_

    <img src="https://i.loli.net/2019/07/16/5d2d750c5845998231.png">

    <img src="https://i.loli.net/2019/07/16/5d2d74b809e3e35520.png">

- 如何避免死锁
  - 避免一个线程获取多个锁
  - 避免一个线程在锁内同时占用多个资源,尽量保证只占用一个资源
  - 尝试使用定时锁时,采用 Lock.tryLock(timeout)来替代 synchronized
  - 数据库锁需要保证枷锁和解锁都在同一个数据库连接中

---

### 资源限制

- 资源限制是指: 在进行并发编程的时候, 程序的执行速度受限于计算机硬件资源或者软件资源, 会导致程序执行速度变慢

- 针对硬件资源的限制: 可以通过使用集群来避免.

- 针对软件资源的限制: 可以使用资源池将资源复用

---

### 原子性

_不可被中断的一个或一系列操作_

#### 处理器实现原子性

- 使用总线锁保证原子性
  使用处理器提供的一个`LOCK#信号`,当一个处理器在总线上输出此信号时,其他处理器的请求被阻塞住, 那么该处理器可以独占共享内存.

- 使用缓存锁保证原子性
  缓存锁定是指内存区域如果被缓存在处理器的缓存行中,并且在 Lock 操作期间被锁定, 那么当它执行锁操作回写到内存时, 处理器不在总线上声言 LOCK#信号, 而是修改内存的内存地址, 并允许它的`缓存一致性`来保证操作的原子性
  - 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行(cache line)时，则处理器会调用总线锁定。
  - 有些处理器不支持缓存锁定

#### Java 实现原子性

- 使用循环 CAS 实现原子操作

- 使用锁机制实现原子操作

## 知识拓展

### 拓展 1: 单核和多核 cpu 在不同的 os 下进程和线程问题

- 单核 cpu 可以并发实现同时执行多个进程(或者说线程): 它只能把 CPU 运行时间划分成若干个时间段,再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态.

- 多核 cpu 可以并行实现同时执行多个进程(或者说线程): 当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行.

- 但是在 windows 系统下: 多核 cpu 下只能并发执行多进程,但是可以并行实现多线程(待验证)

### 拓展 2: 如何理解进程和线程的多种方式

- 单进程单线程：一个人在一个桌子上吃菜
- 单进程多线程：多个人在同一个桌子上一起吃菜.
- 多进程单线程：多个人每个人在自己的桌子上吃菜.
- 对于 Windows 来说, 加一张桌子开销很大, 所以 Windows 鼓励大家在一个桌子上吃菜, 所以需要面对线程资源争抢与同步的问题.
- 对 Linux 而言, 开一张新桌子开销很小, 所以可以尽可能多开新桌子, 但是在不同桌子上说话不方便, 所以需要研究进程间的通信.
