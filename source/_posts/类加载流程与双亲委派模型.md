---
title: 类加载流程与双亲委派模型
date: 2020-03-13 16:48:17
toc: true
tags: Java
thumbnail: https://image.leejay.top/image/20200511/qBSNbtXB8iRT.jpg?imageslim
---

## 实例化与初始化

在分析类加载流程之前，需要先明白一个概念：`无论是类还是对象，实例化对应着开辟内存空间赋予对象或类的过程，而初始化则对应着类或对象参数赋值的过程。`

---

## 类加载流程
当一个Java类被加载进JVM内存，到卸出内存，会经历下图七个阶段。

![](https://image.leejay.top/Fp0TSKAc1i8rSPKcAe1t36qz4a7e)
> 其中加载、验证、准备、初始化和卸载这5个阶段的顺序是固定的，但是`解析阶段`不一定，可以在初始化之后再开始(用于支持Java语言的运行时绑定)。

<!--more-->
---

### 加载

在此阶段，JVM需要完成如下事情：
1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的`静态存储结构`转化为`方法区的运行时数据结构`(读取到方法区中)
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
加载过程是需要类加载器参与的。

### 验证
是为了确保`Class文件`的字节流中包含的信息符合JVM的需求，验证包括`文件格式验证、元数据验证、字节码验证和符号引用验证`。

### 准备
此阶段是正式为了`类变量分配内存并设置类变量初始化的阶段`，这些变量使用的内存都将在`方法区`中进行分配。这些变量仅为`被static修饰的类变量，不包括实例变量，实例变量会随着对象实例化而分配在内存中`。而变量初始化则是将`数据类型的类变量初始化为零值`。

```java
// 准备阶段初始化为0
public static int a = 123;
// 准备阶段初始化为123
public static final a = 123;
```
> 如果类变量被final修饰，就不会初始化为零值。

### 解析
此阶段是JVM将`常量池内的符号引用替换为直接引用`的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

### 初始化（重要）
在编译生成class文件时，会自动生成两个方法：`<clinit>(类构造器)`和`<init>(实例构造器)`。类初始化是类加载过程的最后一步，到了此阶段`才真正开始执行类中定义的Java程序代码`，或者说：`初始化阶段是执行类构造器<clinit>()方法的过程。` 

#### 类构造器

- 概念：
`<clinit>`由编译器自动收集类中的所有`类变量的赋值动作和静态代码块中的语句`合并产生的，编译器收集的顺序是由文件中出现的顺序决定的，用于初始化类变量及执行静态代码块。

- 特征：
    1. JVM会保证子类的`<init>`在执行之前，父类的`<clinit>`已经执行完毕。
    2. 如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产`<clinit>()`方法。
    3. 接口的子类或实现类的`<clinit>()`方法不需要先执行接口的`<clinit>`()方法。只有当`接口中定义的变量使用时，接口才会初始化`。
    4. JVM会保证一个类的`<clinit>()`方法在多线程环境中被正确的加锁、同步。如果多个线程同时初始化一个类，那么`只会有一个线程`去执行这个类的`<clinit>()`方法，其他线程都需要阻塞等待，直到活动线程执行`<clinit>()`方法完毕

   ``` java
    public class InnerSingleton {

        private InnerSingleton() {}

        public static InnerSingleton getInstance() {
            // 内部类只有在被调用的时候才会创建，然后创建SINGLETON，实现懒加载
            return Inner.SINGLETON;
        }

        private static class Inner {
            // 对于一个类，JVM在仅用一个类加载器加载它时，静态变量的赋值在全局只会执行一次！
            // 且JVM会保证一个类的<CInit>()方法（初始化方法）执行时的线程安全，从而保证了实例在全局的唯一性
            private static InnerSingleton SINGLETON = new InnerSingleton();
        }
    }
    ```

- 触发条件：
    1. 遇到 new, getstatic, putstatic, invokestatic 这些字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。比如`new实例化对象、读取一个类的静态字段或调用一个类的静态方法`。
    2. 使用`反射对类进行调用`时，如果类没有进行过初始化，则需要先触发其初始化。
    3. 当初始化一个类的时候，如果`其父类还没有进行过初始化`，则需要先触发其父类的初始化。
    4. 当虚拟机启动时，用户需要指定一个要执行的`主类`（包含main()方法的那个类），虚拟机会先初始化这个主类。

- 代码验证：

  ```java
  // 模拟类加载、对象实例化和对象初始化流程
    public class Objects extends FatherObjects {

        // 3. 执行子类静态代码块
        static {
            System.out.println("i'm objects ... ");
        }
        // 6. 先初始化成员变量，并赋予默认值0
        private int i;

        // 7. 再执行构造函数，并进行变量赋值
        public Objects(int i) {
            System.out.println("Objects init ... ");
            this.i = i;
        }
    }

    class FatherObjects {
        // 1.加载父类静态变量或静态代码块(取决于代码顺序)
        static String name = "hello";

        // 4. 加载父类实例成员变量
        int age;

        // 2.加载静态代码块
        static {
            System.out.println(name);
            System.out.println("i'm FatherObjects ... ");
        }
        // 5.加载父类构造函数
        FatherObjects() {
            System.out.println("FatherObjects init ...");
        }
    }

    class Test {
        public static void main(String[] args) {
            Objects objects = new Objects(1);
        }
    }

    ```
---

## 双亲委派模型

### 概念

每次收到类加载请求时，`先将请求委派给父类加载器完成(所有加载请求最终会委派到顶层的Bootstrap ClassLoader加载器中)`，如果父类加载器无法完成这个加载(该加载器的搜索范围中没有找到对应的类)，`子类尝试自己加载`，如果都没加载到则会抛出 ClassNotFound异常。

![](https://image.leejay.top/FnmD1lcBoQOKWyvzf1G97kmGvj73)

``` java

class Test {
    public static void main(String[] args) throws Exception {
        // 获取Bootstrap ClassLoader加载的文件
        System.out.println(System.getProperty("sun.boot.class.path"));
        // 获取ExtClassLoader加载文件
        System.out.println(System.getProperty("java.ext.dirs"));
        // 获取
        System.out.println(System.getProperty("java.class.path"));

    }
}

```

### 类加载方式

#### Class.forName()

1. 保证一个Java类被有效得加载到内存中。
2. `类默认会被初始化`，即执行内部的静态块代码以及保证静态属性被初始化。
3. 默认会使用`当前的类加载器`来加载对应的类。

#### ClassLoader.loadClass()

1. 类会被加载到内存中。
2. `类不会被初始化，只有在之后被第一次调用时类才会被初始化。`

---