---
title: 多线程实战1
date: 2019-01-01 10:44:32
tags: Java
toc: true
categories:
  - 多线程
thumbnail: https://tvax1.sinaimg.cn/large/005BYqpggy1g4mghnm1y2j30sg0lcaan.jpg
---

## 线程的基本概念

- 单线程程序
  只有一个线程在运行（严格来讲，java 处理后台也有线程在运行，例如 GC 回收和 GUI 相关线程）
- 多线程程序
  由多个线程组成的程序（多用于多个客户端访问，GUI 应用程序，耗时的 I/O 处理等）

## 多线程

```java
public class SingleThread {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        // start()启动一个新的线程，run方法不会调用新的线程
        thread.start();
        for (int i = 0; i < 100; i++) {
            System.out.print("GOOD!");
        }
    }
}

class MyThread extends Thread {

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.print("NICE!");
        }
    }
}
```

- run 方法是不会启动新的线程，通过 new Thread().start 启动新的线程。
- 顺序，并行和并发
  顺序： 多个操作依次处理
  并行： 多个操作同时处理
  并发： 将一个操作分割成多个部分并且允许无序处理（<font color="red">如果 cpu 只有一个，那么并发处理就是顺序执行，如果是多个，那么并发处理就是并行处理。</font>）

<!-- more -->

## 线程的启动

### 利用 Thread 子类的实例启动线程

```java
public class ThreadChapter2 {
    public static void main(String[] args) {
        new PrintThread("GOOD").start();
        new PrintThread("NICE").start();
    }
}

class PrintThread extends Thread {
    private String message;

    PrintThread(String message) {
        this.message = message;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.print(message);
        }
    }
}
```

- 即便创建了实例，但是不调用<code>start</code>方法，线程也不会启动，即使线程终止了，该实例也不会消失。

- main 方法中启动两个线程，随后 main 方法终止，主线程也会终止，但是整个程序并不会终止，直到所有的线程都终止后，程序才会终止。

- java 程序的终止是指守护线程（Daemon Thread）以外的线程全部终止。守护线程是执行后台作业的线程，我们可以通过 setDaemon()将线程设置成守护线程。

### 利用 Runnable 实现类的实例启动线程

```java
public class ThreadChapter3 {
    public static void main(String[] args) {
        new Thread(new PrintRunner("GOOD")).start();
        new Thread(new PrintRunner("NICE")).start();
    }
}

class PrintRunner implements Runnable {
    private String message;

    PrintRunner(String message) {
        this.message = message;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.print(message);
        }
    }
}
```

- 将 printRunner 的实例作为参数传入 Thread 的实例中，调用 start 方法启动线程。

### 通过 ThreadFactory 创建线程

```java
public class ThreadChapter4 {
    public static void main(String[] args) {
        ThreadFactory factory = Executors.defaultThreadFactory();
        factory.newThread(new PrintRunner("GOOD!")).start();
        for (int i = 0;i< 100;i++) {
            System.out.print("NICE!");
        }
    }
}
```

## 线程的暂停

- sleep 能够暂停线程运行

```java
public class ThreadChapter5 {
    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            System.out.println("GOOD!");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

## 线程的互斥

### syncnronized 方法

- 线程 A,B 之间互相竞争而引起的与预期相反的情况成为数据竞争或竞态条件。
- 如果一个线程正在执行一部分操作，那么其他线程就不可以再执行这部分操作，这称为互斥。
- java 使用<code>synchronized</code>来执行线程的互斥处理。声明方法前加上该字段，<font color="red">表明该方法只能由一个线程运行,而不是让特定线程去执行。</font>

```java
public class ThreadChapter6 {
    private int money;
    private String name;

    public ThreadChapter6(int money, String name) {
        this.money = money;
        this.name = name;
    }

    public String getName() {
        return name;
    }

    // 存款
    public synchronized void deposit(int m) {
        money += m;
    }

    //取款
    public synchronized boolean withdraw(int m) {
        if (money >= m) {
            money -= m;
            //取款成功
            return true;
        } else {
            return false;
        }
    }
}
```

- 当一个线程运行 deposite 方法时，由于该线程获取了锁，所以其他线程就无法运行该实例中的 synchronized 方法。
- <font color="green">每个实例拥有一个独立的锁，并不是说某一个实例中的 synchronized 方法正在运行，其他实例中的 synchronized 就不能运行了。</font>
- 线程的互斥机制成为**监视**，获取锁称为拥有监视/持有锁，判断当前线程是否获取某一对象的的锁可以通过<code>assert Thread.holdsLock(obj)</code>来确认

### syncnronized 代码块

- 如果只想让方法中的某一块由一个线程执行,而非整个方法,可以使用 syncnronized 代码块。
- syncnronized 实例方法和代码块(<font color="red">syncnronized 实例方法是使用 this 的锁来执行线程互斥处理</font>)

```java
syncnronized void method(){

}
等同于
void method(){
  syncnronized (this){

  }
}
```

- syncnronized 静态方法和代码块（<font color="red">使用该类的类对象的锁来执行线程的互斥处理</font>）

```java
class something {
 static syncnronized void method(){

 }
}
等同于
class something {
  static void method(){
    syncnronized (something.class){

    }
  }
}
```

## 线程的协作

### 等待队列

- 所有的实例都拥有一个等待队列，它是在实例的 wait 方法执行后停止操作的线程队列。

- 执行 wait 方法后，线程便会暂停操作，以下情况出现，线程会退出等待队列：
  - 其他线程的 notify 方法唤醒线程
  - 其他线程的 notifyAll 方法唤醒
  - 其他线程 interrupt 方法来唤醒线程
  - wait 方法超时

### wait

- wait 方法会让线程进入等待队列，如果执行 wait 方法，线程必须持有当前实例的锁（这是规则），但是如果线程进入等待队列，便会释放其实例的锁。(<font color="red">wait() == this.wait()</font>)

- wait 方法执行流程： 1.获取了锁的线程 A 执行 wait 方法 2.线程 A 进入等待队列，释放锁 3.线程 B 获取锁

### notify

- notify 方法将队列中的一个线程取出，<font color="red">同样需要拥有当前实例的锁</font>

- notify 唤醒的线程并不会在执行 notify 的一瞬间重新运行！

- 如果没有指定某线程 notify，默认是最早 wait 的线程，但是还是有调度器决定，无法人为控制

- notify 执行流程： 1.此时线程等待队列中有线程 A 2.线程 B 获取锁执行 this.notify()，唤醒 this 等待队列中的一个线程 A（<font color="red">多个等待线程就不一定是 A</font>） 3.线程 A 退出等待队列，想要执行<font color="red">进入 wait 前的下一个操作</font>，但是此时线程 B 仍持有锁。 4.执行了 notify 的线程 B 释放了锁，退出等待的线程 A 获取了锁，执行 wait 的下一个操作。

### notifyAll

- notifyAll 方法会将等待队列中的所有线程都取出来。<font color="red">同样需要拥有当前实例的锁</font>

- obj.notifyAll()会将 obj 实例的等待队列中的线程全部唤醒，但是只能由一个线程获取锁，其他的唤醒的线程处于阻塞状态。

### wait&notify&notifyAll 总结

- notify 比 notify 更迅速，但是 notifyAll 更健壮

- 三者既是 object 类的方法（针对实例的等待队列的操作，且所有实例都有队列），也是 Thread 类的方法（Object 类是所有类的父类）。

### sleep 和 wait 的区别

- sleep 不会释放当前的锁，sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。，而 wait 会释放当前的锁，加入等待队列，直到 notify/notifyAll 唤醒。

### 多线程运行

- 静态方法不能由多个线程同时运行
- 实例不同，锁也就不同，同步方法也可以由多个线程同时运行
- 同一实例的同步方法同时只能由一个线程运行
