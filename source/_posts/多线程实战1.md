---
title: 多线程实战1
date: 2019-01-01 10:44:32
tags: Java
categories:
- 多线程
---
## 线程的基本概念
* 单线程程序
只有一个线程在运行（严格来讲，java处理后台也有线程在运行，例如GC回收和GUI相关线程）
* 多线程程序
由多个线程组成的程序（多用于多个客户端访问，GUI应用程序，耗时的I/O处理等）

## 多线程

``` java
public class SingleThread {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        // start()启动一个新的线程，run方法不会调用新的线程
        thread.start();
        for (int i = 0; i < 100; i++) {
            System.out.print("GOOD!");
        }
    }
}

class MyThread extends Thread {

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.print("NICE!");
        }
    }
}
```
* run方法是不会启动新的线程，通过new Thread().start 启动新的线程。
* 顺序，并行和并发
顺序： 多个操作依次处理
并行： 多个操作同时处理
并发： 将一个操作分割成多个部分并且允许无序处理（<font color="red">如果cpu只有一个，那么并发处理就是顺序执行，如果是多个，那么并发处理就是并行处理。</font>）

## 线程的启动

### 利用Thread子类的实例启动线程

``` java
public class ThreadChapter2 {
    public static void main(String[] args) {
        new PrintThread("GOOD").start();
        new PrintThread("NICE").start();
    }
}

class PrintThread extends Thread {
    private String message;

    PrintThread(String message) {
        this.message = message;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.print(message);
        }
    }
}
```
* 即便创建了实例，但是不调用<code>start</code>方法，线程也不会启动，即使线程终止了，该实例也不会消失。

* main方法中启动两个线程，随后main方法终止，主线程也会终止，但是整个程序并不会终止，直到所有的线程都终止后，程序才会终止。

* java程序的终止是指守护线程（Daemon Thread）以外的线程全部终止。守护线程是执行后台作业的线程，我们可以通过setDaemon()将线程设置成守护线程。

### 利用Runnable实现类的实例启动线程

``` java
public class ThreadChapter3 {
    public static void main(String[] args) {
        new Thread(new PrintRunner("GOOD")).start();
        new Thread(new PrintRunner("NICE")).start();
    }
}

class PrintRunner implements Runnable {
    private String message;

    PrintRunner(String message) {
        this.message = message;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.print(message);
        }
    }
}
```
* 将printRunner的实例作为参数传入Thread的实例中，调用start方法启动线程。

### 通过ThreadFactory创建线程

``` java
public class ThreadChapter4 {
    public static void main(String[] args) {
        ThreadFactory factory = Executors.defaultThreadFactory();
        factory.newThread(new PrintRunner("GOOD!")).start();
        for (int i = 0;i< 100;i++) {
            System.out.print("NICE!");
        }
    }
}
```

## 线程的暂停

* sleep能够暂停线程运行

``` java
public class ThreadChapter5 {
    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            System.out.println("GOOD!");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

## 线程的互斥

### syncnronized 方法
* 线程A,B之间互相竞争而引起的与预期相反的情况成为数据竞争或竞态条件。
* 如果一个线程正在执行一部分操作，那么其他线程就不可以再执行这部分操作，这称为互斥。
* java使用<code>synchronized</code>来执行线程的互斥处理。声明方法前加上该字段，<font color="red">表明该方法只能由一个线程运行,而不是让特定线程去执行。</font>

``` java
public class ThreadChapter6 {
    private int money;
    private String name;

    public ThreadChapter6(int money, String name) {
        this.money = money;
        this.name = name;
    }

    public String getName() {
        return name;
    }

    // 存款
    public synchronized void deposit(int m) {
        money += m;
    }

    //取款
    public synchronized boolean withdraw(int m) {
        if (money >= m) {
            money -= m;
            //取款成功
            return true;
        } else {
            return false;
        }
    }
}
```
* 当一个线程运行deposite方法时，由于该线程获取了锁，所以其他线程就无法运行该实例中的synchronized方法。  
* <font color="green">每个实例拥有一个独立的锁，并不是说某一个实例中的synchronized方法正在运行，其他实例中的synchronized就不能运行了。</font>
* 线程的互斥机制成为**监视**，获取锁称为拥有监视/持有锁，判断当前线程是否获取某一对象的的锁可以通过<code>assert Thread.holdsLock(obj)</code>来确认

### syncnronized 代码块
* 如果只想让方法中的某一块由一个线程执行,而非整个方法,可以使用syncnronized代码块。
* syncnronized实例方法和代码块(<font color="red">syncnronized实例方法是使用this的锁来执行线程互斥处理</font>)

``` java
syncnronized void method(){

}
等同于
void method(){
  syncnronized (this){
  
  }
}
```

* syncnronized 静态方法和代码块（<font color="red">使用该类的类对象的锁来执行线程的互斥处理</font>）

```java
class something {
 static syncnronized void method(){
 
 }
}
等同于
class something {
  static void method(){
    syncnronized (something.class){

    }
  }
}
```

## 线程的协作

### 等待队列
* 所有的实例都拥有一个等待队列，它是在实例的wait方法执行后停止操作的线程队列。

* 执行wait方法后，线程便会暂停操作，以下情况出现，线程会退出等待队列：
  * 其他线程的notify方法唤醒线程
  * 其他线程的notifyAll方法唤醒
  * 其他线程interrupt方法来唤醒线程
  * wait方法超时

### wait
* wait方法会让线程进入等待队列，如果执行wait方法，线程必须持有当前实例的锁（这是规则），但是如果线程进入等待队列，便会释放其实例的锁。(<font color="red">wait() == this.wait()</font>)

* wait方法执行流程：
  1.获取了锁的线程A执行wait方法
  2.线程A进入等待队列，释放锁
  3.线程B获取锁

### notify
* notify方法将队列中的一个线程取出，<font color="red">同样需要拥有当前实例的锁</font>

* notify唤醒的线程并不会在执行notify的一瞬间重新运行！

* 如果没有指定某线程notify，默认是最早wait的线程，但是还是有调度器决定，无法人为控制

* notify执行流程：
  1.此时线程等待队列中有线程A
  2.线程B获取锁执行this.notify()，唤醒this等待队列中的一个线程A（<font color="red">多个等待线程就不一定是A</font>）
  3.线程A退出等待队列，想要执行<font color="red">进入wait前的下一个操作</font>，但是此时线程B仍持有锁。
  4.执行了notify的线程B释放了锁，退出等待的线程A获取了锁，执行wait的下一个操作。

### notifyAll

* notifyAll方法会将等待队列中的所有线程都取出来。<font color="red">同样需要拥有当前实例的锁</font>

* obj.notifyAll()会将obj实例的等待队列中的线程全部唤醒，但是只能由一个线程获取锁，其他的唤醒的线程处于阻塞状态。

### wait，notify，notifyAll总结
* notify比notify更迅速，但是notifyAll更健壮

* 三者既是object类的方法（针对实例的等待队列的操作，且所有实例都有队列），也是Thread类的方法（Object类是所有类的父类）。

### sleep和wait的区别
* sleep不会释放当前的锁，sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。，而wait会释放当前的锁，加入等待队列，直到notify/notifyAll唤醒。

### 多线程运行
* 静态方法不能由多个线程同时运行
* 实例不同，锁也就不同，同步方法也可以由多个线程同时运行
* 同一实例的同步方法同时只能由一个线程运行