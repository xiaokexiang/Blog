---
title: 深入学习多线程
date: 2019-02-21 14:58:57
tags: Java
categories:
- 多线程
---
## 使用Interrupted实现耗时资源线程的打断
如果执行时间超过设置时间自动打断
``` Java
public class ThreadInterrupted5 {
    private Thread execThread = new Thread();
    private volatile Boolean finish = Boolean.FALSE;

    /**
     * 用于执行耗时任务,原理是执行线程创建子线程作为守护线程,执行线程结束,那么他的守护线程也会结束
     * 如果是在main线程中创建守护线程,那么只有main线程结束,那么此守护线程才会结束
     * 如果只是创建非守护线程,不一定会在main结束时就结束
     */

    public void exec(Runnable task) {
        execThread = new Thread(() -> {
            Thread thread = new Thread(task);
            thread.setDaemon(true);
            thread.start();
            try {
                //保证thread在execThread前执行
                thread.join();
                finish = Boolean.TRUE;
            } catch (InterruptedException e) {
                System.out.println("执行线程打断了,带着守护线程也被打断啦...");
            }
        });
        execThread.start();
    }

    public void shutdown(long millis) {
        long begin = System.currentTimeMillis();
        while (!finish) {
            if ((System.currentTimeMillis() - begin) >= millis) {
                System.out.println("任务超时,需要结束...");
                execThread.interrupt();
                break;
            }
            try {
                Thread.sleep(1);
            } catch (InterruptedException e) {
                System.out.println("执行线程未到超时时间已完成,自动结束...");
                break;
            }
        }
        finish = false;
    }

    public static void main(String[] args) {
        long begin = System.currentTimeMillis();
        ThreadInterrupted5 thread = new ThreadInterrupted5();
        thread.exec(() -> {
            /**
             * 假设任务一直执行
             * while(true){
             * }
             */
            /**
             * 假设任务执行时间5s少于预设打断的时间10s
             */
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        thread.shutdown(10000);
        System.out.println("执行任务时长: " + (System.currentTimeMillis() - begin));
    }
}

```

## 线程间的通讯
* wait & notify

``` Java
/**
 * @Author: Lucky
 * @Date: 3/4/2019
 * @Description: 使用wait和notify实现线程间的通信: producer生产一个,consumer消费一个
 */
public class ThreadConnection {
    private int index = 0;
    private final Object lock = new Object();
    private volatile boolean flag = Boolean.FALSE;

    // 生产者
    private void producer() {
        synchronized (lock){
            if (flag) {
                // 此时已经有货物,等待consumer消费2
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            } else {
                // 生产货物
                index++;
                System.out.println("p ->" + index);
                lock.notify();
                flag = Boolean.TRUE;
            }
        }
    }

    // 消费者
    private void consumer() {
        synchronized (lock) {
            if (flag) {
                // 消费货物,提醒生产者生产
                System.out.println("c ->" + index);
                lock.notify();
                flag = Boolean.FALSE;
            } else {
                try {
                    // 没有货物继续等待
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) {
        ThreadConnection threadConnection = new ThreadConnection();
        new Thread(() -> {
            while (true) {
                threadConnection.producer();
            }
        }).start();
        new Thread(() -> {
            while (true) {
                threadConnection.consumer();
            }
        }).start();
    }
}
```

* wait & notifyAll 

``` Java
/**
 * @Author: Lucky
 * @Date: 3/4/2019
 * @Description: 多个producer和consumer 如何保证不重复生产或消费
 * 多线程中使用while而不是if 因为在notifyAll()时,抢到锁的线程会去执行,没抢到的会执行wait下面的代码,
 * 所以需要while重复判断,保证不会多生产  <links>notifyAll 会唤醒全部的wait线程,但是只会有一个线程获取锁</>
 */
public class ThreadConnection2 {
    private int index = 0;
    private final Object lock = new Object();
    private volatile boolean flag = Boolean.FALSE;

    // 生产者
    private void producer() {
        synchronized (lock) {
            while (flag) {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            // 生产货物
            index++;
            System.out.println("p ->" + index);
            // 唤醒全部,而不是唤醒一个
            lock.notifyAll();
            flag = Boolean.TRUE;
        }
    }

    // 消费者
    private void consumer() {
        synchronized (lock) {
            while (!flag) {
                try {
                    // 没有货物继续等待
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            // 消费货物,提醒生产者生产
            System.out.println("c ->" + index);
            lock.notifyAll();
            flag = Boolean.FALSE;
        }
    }

    public static void main(String[] args) {
        ThreadConnection2 threadConnection2 = new ThreadConnection2();
        Stream.of("P1", "P2", "P3").forEach(p -> new Thread(p) {
            @Override
            public void run() {
                while (true) {
                    threadConnection2.producer();
                }
            }
        }.start());
        Stream.of("C1", "C2", "C3").forEach(p -> new Thread(p) {
            @Override
            public void run() {
                while (true) {
                    threadConnection2.consumer();
                }
            }
        }.start());
    }
}
```

* 面试题: 交替打印奇偶数(可以不使用wait和notify实现)

``` Java
/**
 * @Author: Lucky
 * @Date: 3/4/2019
 * @Description: 之前的面试题: 交替打印奇偶数
 * 其实使用wait和notify实现是搞复杂了,这里只是使用刚学习的技巧来实现该功能
 */
public class PrintOdevity {
    private volatile AtomicInteger index = new AtomicInteger(0);
    private final Object lock = new Object();
    // false -> 打印奇數 true -> 打印偶數
    private volatile boolean flag = Boolean.FALSE;

    // 打印奇数
    private void printOdd() {
        synchronized (lock) {
            if (flag) {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            } else {
                System.out.println("奇数: ---->" + index.incrementAndGet());
                lock.notify();
                flag = Boolean.TRUE;
            }
        }
    }

    // 打印偶数
    private void printEven() {
        synchronized (lock) {
            if (flag) {
                System.out.println("偶数: ---->" + index.incrementAndGet());
                lock.notify();
                flag = Boolean.FALSE;
            } else {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) {
        PrintOdevity printOdevity = new PrintOdevity();
        new Thread(() -> {
            while (true) {
                printOdevity.printOdd();
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();

        new Thread(() -> {
            while (true) {
                printOdevity.printEven();
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }
}

```

## wait和sleep的区别

* wait是所有Object拥有的方法,sleep是Thread的方法
* wait会释放锁,sleep会占有锁
* wait需要被wakeup,sleep不需要
* 使用wait必须要有synchronize,sleep不需要