---
title: 多线程实战2
date: 2019-01-11 13:27:45
tags: Java
toc: true
categories:
  - 多线程
thumbnail: https://tvax1.sinaimg.cn/large/005BYqpggy1g4mghnm1y2j30sg0lcaan.jpg
---

## 多线程程序的评价标准

- 安全性
  安全性就是不损坏对象，是程序运行的必要条件。

- 生存性
  无论什么时候，必要的处理一定能够被执行。是程序运行的必要条件
- 可复用性
  类能够重复利用，是提高程序质量的必要条件。

- 性能
  指能够快速，大批量的执行处理，包括吞吐量，响应和容量，是提高程序质量的必要条件。

- <font color="red">一个类被多个线程同时使用，也可以正常正确的执行，这个类被称为线程安全的。</font>

- Q： 如果把线程个数变为 2 倍，那么吞吐量是不是也会变为两倍？
  A：一般不会变为两倍。
- 受到硬件的限制，2 倍的线程不一定可以真正的同时运行，另外也会导致线程切换的额外开销。
- 所要处理的的工作不一定能平均分配给所有线程。
- 即使没有硬件限制，2 倍线程可以并发运行，执行线程间的互斥操作也会造成额外的开销。

<!-- more -->

## Single Threaded Execution 模式

- 确保同一时间内只能让一个线程执行处理。

- Q： Java 构造函数是线程安全的吗？

  A: 只有涉及资源共享的时候才考虑线程安全问题，即使多个线程同时构造同一个类的对象，它们各自构造的对象之间也是互不相干的，不存在共享资源，所以给构造函数本身加 synchronized 是没有什么意义的。但是如果在构造函数内部确实有读写共享资源（如静态变量），这时仍然需要对相关的资源进行同步，依具体情况而定。

- Q： 三个人频繁的通过只允许一个人经过的门。

```java

public class ThreadChapter1 {
    public static void main(String[] args) {
	    // 三个线程都使用的是同一个gate对象（共享实例）
        Gate gate = new Gate();
        new UserThread(gate, "Alice", "Alaska").start();
        new UserThread(gate, "Bobby", "Brazil").start();
        new UserThread(gate, "Chris", "Canada").start();
    }
}

// 非线程安全的Gate(门)类
class Gate {
    private int counter = 0;
    private String name = "Nobody";
    private String address = "NoAddress";

    public synchronized void pass(String name, String address) {
        this.counter++;
        this.name = name;
        this.address = address;
        check();
    }

    public synchronized String toString() {
        return "No." + counter + ": " + name + ", " + address;
    }

    private void check() {
        if (name.charAt(0) != address.charAt(0)) {
            System.out.println("****BROKEN****" + toString());
        }
    }


}

class UserThread extends Thread {

    private final Gate gate;
    private final String myName;
    private final String myAddress;

    UserThread(Gate gate, String myName, String myAddress) {
        this.gate = gate;
        this.myName = myName;
        this.myAddress = myAddress;
    }

    @Override
    public void run() {
        System.out.println(myName + " BEGIN");
        for (; ; ) {
            gate.pass(myName, myAddress);
        }
    }
}
tips： 因为线程改写共享的实例字段时并未考虑其他线程的操作导致的问题,通过pass和toString同步方法即可
```

### 拓展思路

- Single Threaded Execution 模式中出现了一个发挥 sharedResource（共享资源）作用的类。

- Single Threaded Execution 模式会保护 unsafeMethod，使其同时只能有一个线程访问。

- Single Threaded Execution 模式何时使用：
  - sharedResource 角色的实例有可能被多个线程同时访问时。
  - sharedResource 角色的状态发生变化。
  - 需要确保线程安全时。
- Single Threaded Execution 模式发生死锁的条件：

  - 存在多个 SharedResource 角色
  - 线程在持有某个 SharedResource 角色锁的同时还向获取其他 SharedResource 角色的锁
  - 获取 SharedResource 角色的锁的顺序不固定

- Single Threaded Execution 模式会降低程序性能：

  - 线程需要获取锁花费时间
  - 线程冲突（线程 A 执行临界区的处理，线程 B 等待）引起的等待。

- HashTable 和 ConcurrentHashMap
  <font color="red">HashTable 使用的是 Single Threaded Execution，而 ConcurrentHashMap 是将内部数据结构分成多段，针对各段操作的线程互不相干，所以 HashTable 更容易引起线程冲突，性能也没有 ConcurrentHashMap 好。</font>

- synchronized 方法和 synchronized 代码块无论是 return 或者是抛出异常，都一定能释放锁！！！！

- 捕获线程异常：

```java
 // 捕获具体的多线程异常
   new Thread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
     @Override
     public void uncaughtException(Thread t, Throwable e) {
            System.out.println(e.getMessage());
            }
        });
```

- 基本类型的原子性

  - char，int 等基本类型的赋值和引用操作都是原子性的
  - long,double 不是原子性的
  - 在 synchronized 中操作 long，double 类型，或者声明为 volatile！

- 使用 concurrent 中表示计数信号量的 Semaphore 类实现某区域最多 N 个线程执行

```java
public class ThreadChapter2 {
    public static void main(String[] args) {
        BoundedResource boundedResource = new BoundedResource(3);
        for (int i = 0;i<10;i++) {
            new UserThread2(boundedResource).start();
        }
    }
}

// 资源类
@Slf4j
class BoundedResource {
    private final Semaphore semaphore;
    private final int permits;
    // 如果seed种子相同，那么每次的随机序列也是相同的，是伪随机序列
    private static final Random random = new Random(314159);

    // 资源类构造函数，permits为资源个数
    public BoundedResource(int permits) {
        this.semaphore = new Semaphore(permits);
        this.permits = permits;
    }

    //使用资源
    public void use() throws InterruptedException {

        // 是否存在可用资源，如果没有会阻塞在此方法中
        semaphore.acquire();
        try {
            doUse();
        } finally {
            //释放资源，也可以指定释放数量
            semaphore.release();
        }
    }

    // 使用资源封装的方法
    private void doUse() throws InterruptedException {
        // semaphore.availablePermits() 当前可用线程
        log.info("BEGIN:  used = " + (permits - semaphore.availablePermits()));
        Thread.sleep(random.nextInt(500));
        log.info("END:  used = " + (permits - semaphore.availablePermits()));
    }
}

class UserThread2 extends Thread {
    private static final Random random = new Random(25565);
    private final BoundedResource boundedResource;

    public UserThread2(BoundedResource boundedResource) {
        this.boundedResource = boundedResource;
    }

    @Override
    public void run() {
        try {
            for (; ; ) {
                boundedResource.use();
                Thread.sleep(random.nextInt(3000));
            }
        } catch (InterruptedException e) {

        }
    }
}
```

- 如何实现快速查找出线程不安全的错误？
  A： 延长临界区（修改或者引用实例状态的地方就叫做临界区，或者理解成线程不安全的代码块区域，比如 Thread.Sleep（）可以起到延时的作用）可以提高检查出线程错误的可能性！
