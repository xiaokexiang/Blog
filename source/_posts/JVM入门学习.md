---
title: JVM入门基础
toc: true
date: 2019-12-26 14:46:51
tags: Java
categories:
  - Jvm
thumbnail: https://img.vim-cn.com/a3/1bd74b67fa66c7f1473f31da0dcddc21c342b7.png
---

### Java 数据类型

- 基本数据类型

  ```java
  byte(1) short(2) int(4) long(8) float(4) double(8) char(2) boolean(1) 单位:byte
  前四个是有符号整数型，float和double是浮点数，chart是无符号整数型(无负数)，boolean是布尔值
  ```

- 引用数据类型

  类、接口、泛型类型和数组类型。

- 整数在 JVM 中的表示

  整数在计算机中是用`补码`展示的，在 JVM 中也是如此，规则如下:

  `正整数的补码就是原码，负整数的原码就是反码(原码的符号位除外取反)+1`

  ```java
  byte a = 10; 原码: 0000 1010 -> 反码: 0000 1010 -> 补码: 0000 1010
  byte b = -10; 原码 1000 1010 -> 反码: 1111 0101 -> 补码: 1111 0110
  ```

- 浮点数在 JVM 中的表示

  ```java
  float -> 符号位(1bit)sflag + 指数位(8bit)e + 尾数位(23位)m -> sflag*m*2^(e-127)
  举例: 计算浮点数: 1 10000001 01000000000000000000000 的实际值
   1。 sflag: -1;e: 129;m: e不全为0
   2。 m -> (1)01000000000000000000000， 1*2^0+0*2^-1+1*^-2+0*2^-3+。。。= 1。25
   3。 -1*2^(129-127)*1。25 = -5
  ```

  <!--more-->

  进制及进制计算不清楚的可以看这篇文章: <a href="https://www。leejay。top/posts/Java%E8%BF%9B%E5%88%B6%E8%AF%A6%E8%A7%A3/">Java 进制详解</a>

---

### JVM 基本结构

#### 1. 类加载子系统

`负责从文件或者网络中加载 Class 信息，并将类信息存放在方法区的内存空间中`

#### 2. 直接内存

`NIO 是允许 Java 程序直接使用直接内存的，直接内存是在 Java 堆外的，直接向系统申请的内存区域，其访问内存的速度优于堆，但是申请内存的速度低于堆内存。堆内存+直接内存需要小于系统内存`

#### 3. 垃圾回收系统

<b>JVM 的重要组成，可以对方法区，堆和直接内存进行回收， Java 所有对象的空间都是隐式的释放</b>

#### 4. 方法区

`除了类的加载信息，方法区可能还会存放运行时常量池信息，包括字符串字面量和数字常量(这部分是 Class 文件中常量池的内存映射)`

&emsp;方法区是所有线程共享区域，用于保存系统的类信息(`比如类的字段，方法，常量池等`)。方法区的大小决定了系统可以保存多少个类，太多的类会导致方法区OOM，需要注意的是如果使用了大量的动态代理，会导致运行时生成大量的类也会导致OOM。
&emsp;在1.6 &1.7 中使用-XX:PermSize=5M -XX:MaxPermSize=5M来配置方法区。而1.8之后永久区被彻底移除，取而代之的是`元数据区`，元数据区可以使用`-XX:MaxMetaspaceSize`指定，这是一块堆外的直接内存，不指定大小的话默认虚拟机会耗尽所有可用系统内存。

#### 5. Java 堆

`虚拟机启动的时候建立，是 Java 程序的主要内存工作区域，几乎全部的对象实例都存放在堆中，堆内存是所有线程共享的区域，整个堆分为新生代和老年代。`

> 新生代: 存放年轻对象的堆空间。年轻对象指刚刚创建的或者经历过垃圾回收次数不多的对象。新生代分为 eden，s0，s1(s0，s1 也称为 from 和 to 区域，它们是两块大小相等，可以互换角色的内存空间)。
> 老年代: 存放老年对象的堆空间。老年对象指经历过多次垃圾回收后仍然存活的对象。

&emsp;在绝大多数情况下，对象首先在 eden 区分配，在一次新生代回收后， 如果对象还活着，则会进入 s0 或 s1，之后每经过一次新生代回收，对象如果存活，它的年龄就会加1，当对象的年龄达到一定程度之后，就会被认为是老年代对象，从而进入老年代对象。

#### 6. Java 栈

`线程私有的，在线程创建的时候被创建，对应着一个栈帧， 其中包含局部变量表、操作数栈和帧数据区等`

&emsp;Java中的函数调用对应着: 栈帧出入栈。Java栈是一块线程私有的内存空间，线程执行的基本行为是函数调用，每次函数调用的数据都是通过 Java 栈传递的。

&emsp;Java 栈是一种`先进先出`的数据结构，支持入栈和出栈两种操作。每一次函数调用都会有一个栈帧被压入 Java 栈，当前正在执行的函数对应的帧就是当前的帧(位于栈顶)。当函数返回的时候， 栈帧从 Java 栈中被弹出(无论是正常的函数返回 return 指令还是异常抛出都会导致栈帧弹出)。

> StackOverFlow 栈溢出: 每次函数调用都会生成对应的栈帧，从而占用一定的空间。当请求的栈深度大于最大的可用栈深度的时候就会抛出该异常， 可以通过-Xss 设置单个线程下的 stack 大小(linux64 位 JDK7 下默认 1MB)，最常见的栈溢出就是递归导致的。

- 局部变量表

  &emsp;是栈帧的重要组成部分，用于保存函数的参数及局部变量，局部变量表的变量只在当前函数中有效，当函数调用结束后，函数栈帧销毁，局部变量表也会销毁。

  &emsp;需要注意的是，如果函数参数或局部变量过多，会占用更多的栈空间，在当前线程下会导致函数的嵌套次数减少。局部变量表中的变量用<font style="color: red;">字(字是指在计算机内存中占据一个内存单元编号的一组二进制串。一般32机器上的一个字对应4个字节)</font>作为单位。long&double 在局部变量表中占两个字， byte、short、int、对象引用占一个字。

  ```java
    public void scope() {
      {
        int a = 0;
        System。out。println(a)
      }
        int b = 1; // b可以复用a的槽位，前提是占用大小相同
    }
  ```

  > 栈帧中的局部变量表槽位是可以复用的，如果局部变量 a 超过了其作用域，那么其作用域后面的变量可能会复用 a 的槽位(`前提是变量的字大小相同`)，达到节省资源的目的
  > 实例方法的局部变量的第 0 个槽位都是`this引用`，之后的才是变量，上面的 scope()方法的槽位只有两个，因为 b 复用了 a 的槽位。推荐使用`Jclasslib`工具，idea plugin 仓库下载。

- 操作数栈

  先进先出的数据结构。主要用于保存计算过程中的中间结果，同时作为计算过程中变量临时的存储空间，简单理解: 执行 iadd 指令，会将两个值在操作数栈中相加，并把结果压入操作数栈

- 帧数据区
  帧数据区保存着`访问常量池的指针`，方便程序访问常量池。除此之外帧数据区还包括`正常方法返回`和`异常处理(异常处理表)`等信息。

  当函数返回或者出现异常的时候，VM 必须恢复调用者函数的栈帧(下一层的栈帧)，并让调用者函数继续执行，而对于异常处理，VM 必须要有一个异常处理表，方便发生异常的时候找到处理异常的代码

  ```java
  Exception table:
  from  to  target  type
  4     16  19      any
  19    21  19      any
  ```

  > 1.  它表示当字节码在 4-16 字节可能抛出`任何`异常，如果遇到异常，就跳到字节码偏移 19 处执行。当方法抛出异常的时候，VM 就会查找异常表来处理。
  > 2.  如果无法在异常表中找到合适的处理方法，就会结束当前函数调用，`返回调用函数`
  > 3.  并在调用函数中抛出相同的异常，并继续查找调用函数的异常表进行处理(原则就是当前处理不了，就找调用者的)。

- 栈上分配

  `是 JVM 提供的一种优化技术，对于线程私有的对象(不可能被其他线程访问的对象)，可以将它们打散分配在栈上，而不是分配在堆上。`好处就是可以在函数调用结束后自行销毁，而不需要 GC 的介入，从而提高性能。

  &emsp;判断是否分配在栈上的基础就是`进行逃逸分析`(判断对象的作用域是否有可能逃出函数体，如果未逃逸，那么有可能将对象分配在栈上)，栈上分配依赖`逃逸分析`和`标量替换(用于打散对象分配在栈上)`的实现，对于大量零散的小对象，栈上分配提供了很好的对象分配策略，但是因为栈空间较小，大对象不适合使用。

#### 7. 本地方法栈

`和 Java 栈类似，是对 native 方法的调用`</b>`

#### 8. PC 寄存器

`也可以叫程序计数器，是线程私有的空间，JVM 会为每个线程创建 PC 寄存器。` 在任意时刻，一个线程总是在执行一个方法，这个正在执行的方法叫做当前方法。如果当前方法不是本地方法，PC 寄存器就会指向当前正在被执行的指令。如果当前方法是本地方法，那么 PC 寄存器的值就是 undefined

#### 9. 执行引擎

`最核心组件之一。负责执行虚拟机的字节码。为了提高效率会使用 JIT(Just In Time: 即时编译技术)编译成字节码后再执行`

---

### JVM 调试参数

#### GC 调试日志参数

```java
  1. -XX:+PrintGC(Java9，10中使用-Xlog:gc) 打印GC日志
  2. -XX:+PrintGCDetails(Java9，10中使用-Xlog:gc*) 打印详细的GC日志
  3. -XX:+PrintHeapAtGC(1。8之后没有) 会在每次GC前后打印堆的信息
  4. -XX:+PrintGCTimeStamps(Java9，10中使用-Xlog:gc*默认打印)，开头的时间为虚拟机启动时间的偏移量
  5. -XX:+PrintGCApplicationConcurrentTime 打印应用程序的执行时间
  6. -XX:+PrintGCApplicationStoppedTime 打印引用程序由于GC而产生停顿的时间
  7. -XX:+PrintReferenceGC(1。8之后没有) 打印系统的引用
  8. -Xloggc:log/gc。log(JDK9，10 -Xlog:gc:log/gc。log) 输出日志到当前log目录下的gc。log文件中

```

#### 类加载卸载

```java
  1. -verbose:class 类的加载和卸载 或使用 -XX:+TraceClassLoading(Java9，10 -Xlog:class+load=info) & -XX:+TraceClassUnloading(Java9，10 -Xlog:class+unload=info)
  2. -XX:+PrintClassHistogram 系统中类分布柱状图
```

#### 查看系统参数

```java
  1. -XX:+PrintVMOptions 打印系统参数
  2. -XX:+PrintCommandLineFlags 打印传递给虚拟机的显式和隐式参数(会将虚拟机启动时自行设置的参数也打印出来)
  3. -XX:+PrintFlagsFinal 全部参数，包括虚拟机自身的参数
```

#### 堆的参数

```java
  1. -Xms: 初始堆空间大小
  2. -Xmx: 最大堆空间大小(实际是-Xmx 减去 from后的大小)。总内存处于-Xms 和 -Xmx 之间， 当前总内存不够会申请内存，如果超过最大内存就会OOM。可以设置-Xms = -Xmx 这样能够减少程序运行垃圾回收的次数，提高程序的性能
  *      ------------------------------
  *      |最大内存                      |
  *      ------------------------------
  *      |总的内存       |
  *      ---------------
  *      |空闲内存  |
  *      ----------
  3. -Xmn: 设置新生代大小(一般设置为整个堆的1/3 ~ 1/4)
  4. -XX:SurvivorRation=eden/from=eden/to   默认 eden:from:to -> 8:1:1
      但from或to中的一个永远是空闲的，所以新生代实际大小是-Xmn设置的9/10
  5. -XX:NewRatio=老年代/新生代 默认2/1
  6. -XX:+HeapDumpOnOutOfMemoryError 在内存溢出时导出整个堆的信息
  7. -XX:HeapDumpPath 指定导出堆的存放路径 -XX:HeapDumpPath=d:/a。dump 导出到D盘下a。dump文件中
```

#### 方法区参数

```java
  1. -XX:PermSize 方法区初始大小(1。6 & 1。7)
  2. -XX:MaxPermSize 方法区最大大小(1。6 & 1。7)
  3. -XX:MaxMetaspaceSize 1。8之后永久区变成元数据区，虽然元数据区大小是由直接内存管理，但是该参数也会指定最大大小
```

#### 栈参数

```java
  1. -Xss: 指定线程的栈大小
```

#### 直接内存

```java
  1. -XX:MaxDirectMemorySize 最大可用直接内存 如果不指定，默认等于-Xmx的大小(直接内存适合申请次数少，频繁访问的场合。对内存相反)
```

#### 虚拟机工作模式

```java
  1. -client: 使用client模式 -server: 使用server模式 默认JVM会根据计算机系统自动选择运行模式
  2. 与client相比，server模式的启动速度较慢，因为会尝试手机更多的系统性能信息，使用更复杂的算法堆程序进行优化，但是server稳定后的执行速度远远快于client
```
---