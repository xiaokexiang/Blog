---
title: 进制详解
toc: true
date: 2019-12-11 15:07:33
tags: Java
categories:
  - Java
thumbnail: https://img.vim-cn.com/f1/baa8d4b25d955cac1a4066c02761e0dd47097d.png
---

## 进制详解

`包括二进制、八进制、十进制和十六进制, 计算机由电路构成, 只有0/1两种状态, 所以采用的是二进制`

### 二进制

`由0 和 1组成, 计算机内部都是二进制的形式存储的。 进行加法运算的时候逢二进一, 减法运算的时候借一当二。在java中0b开头表示二进制值`

- 二进制加法

  <img src="https://img.vim-cn.com/ce/90614dbb397f2d74e43fa6018fda052dda0e30.png" title="图片来源: http://c.biancheng.net/">

- 二进制减法

  <img src="https://img.vim-cn.com/69/d84110b29955cfac1508d813f81403ea399440.png" title="图片来源: http://c.biancheng.net/">

### 十进制

`由0~9的数字组成, 加法计算时逢十进一, 减法计算时借一当十。十进制是人类发展中自然形成的`

<!--more-->

### 八进制

`由0~7的数字组成, 加法计算时逢八进一, 减法计算时借一当八。java中要求第一位是0开始`

- 八进制加法

  <img src="https://img.vim-cn.com/05/465d10e0da0f84f939352ae5f9f01b94ad5547.png" title="图片来源: http://c.biancheng.net/">

- 八进制减法

  <img src="https://img.vim-cn.com/44/f451f84706a30ea176b9fea7162d55fb413a65.png" title="图片来源: http://c.biancheng.net/">

### 十六进制

`由0~9,A(10),B(11),C(12),D(13),E(14),F(15)(不区分大小写)组成, 加法计算时逢十六进一, 减法计算时借一当十六。java中要求以0x开始`

- 十六进制加法

  <img src="https://img.vim-cn.com/bd/1c2e34b69cc0f9ce0d3a7ab8395ae721e20dc3.png" title="图片来源: http://c.biancheng.net/">

- 十六进制减法

  <img src="https://img.vim-cn.com/7c/57fa5cda003cb7d523df343ed909a30f86bd5b.png" title="图片来源: http://c.biancheng.net/">

## 进制互相换算

### 二进制 -> 十进制

假设一个二进制是 1011(3210), 从右往左开始分别是 0、1、2、3 位, 那么它的十进制值为:

```java
   1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 => 8 + 0 + 2 + 1 => 13
```

### 十进制 -> 二进制

假设一个十进制是 13, 一种方法是`除二反序取余法`, 计算如下:

```java
   13/2 = 6 余 1
   6/2 = 3 余 0
   3/2 = 1 余 1
   1/2 = 0 余 1
   反序取余数值, 结果是: 1101
```

另一种计算如下:

```java
 13 => 1*2^3 + 1*2^2 + 0*2^1 + 1*2^0
```

### 二进制 -> 八进制

假设一个二进制是 10110101, 从右往左每`三位`一组`(不足补 0, 二进制三位最大值是 7(111), 最小值是 0, 逢八进一, 这也是八进制的由来)`分别是:

```java
  010 110 101 对应的结果是: 010(2) 110(6) 101(5) => 265
```

### 二进制 -> 十六进制

假设一个二进制是 110110101, 从右往左每`四位`一组`(不足补 0, 二进制四位数最大值是 15(1111), 最小值是0, 逢十六进一， 也是十六进制的由来)`分别是:

```java
  0001 1011 0101 对应的结果是: 1 11(B) 5 => 1B5
```

## 位运算

### 与运算

`两个操作数都是1, 结果是1, 否则是0`

```java
  010100011
& 100011011
————————————
  000000011
```

### 或运算

`两个操作数有一个是1, 结果是1, 否则是0`

```java
  101001001
| 110000101
————————————
  111001101

```

### 异或

`两个操作数相同则为0, 不相同则为1`

```java
  101101011
^ 100100101
————————————
  001001110
```

### 取反运算

`对操作数取相反值`

```java
~ 010101110
————————————
  101010001
```

### 移位运算

`包括左移<< 和 右移 >>, 1 << 2 表示1左移2位, 1 >> 1 表示1右移1位`

```java
   101011001
<<         2
——————————————
   101100100

如果左移没有改变最高位(符号位), 那么将一个整数左移1位相当于乘以2, 编译器做移位比乘法快的多。

   101011001
>>         2
——————————————
   001010110

同理如果没有改变最高位, 那么右移一位相当于除以2
```

## 负数的二进制

### 负数的计算

`因为负数的二进制表达以及位运算的特殊性, 所以单独提出来解释, 在此之前需要了解机器数, 真值, 原码, 反码, 补码的概念`

- 机器数

  `一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1`

  ```java
   +1 -> 0000 0001
   -1 -> 1000 0001
  ```

- 真值

  `因为第一位是符号位, 所以机器数的形式值 ≠ 真正的数值。 比如 1000 0001 其真值是 -1, 而其形式值是129(转成十进制: 2^7 + 2^0)。我们将带符号位的机器数对应的真正数值称为机器数的真值`

- 原码

  `原码就是真值的绝对值加上符号位(最高位), 正数用0, 负数用1表示`

  ```java
  // 假设8bit的二进制的原码
  +1 -> 0 0000001
  -1 -> 1 0000001
  ```

- 反码

  `正数的反码是其本身, 负数的反码是在原码的基础上, 保持符号位不变, 其余的位执行取反操作`

  ```java
  // 假设8bit的二进制的反码
  +1 -> 0 0000001 -> 0 0000001
  -1 -> 1 0000001 -> 1 1111110
  ```

- 补码

  `正数的补码就是其本身, 负数的补码就是在其反码的基础上 + 1`

  ```java
  // 假设8bit的二进制的补码
  //真值   原码         反码         补码
  +1 -> 0 0000001 -> 0 0000001 -> 0 0000001
  -1 -> 1 0000001 -> 1 1111110 -> 1 1111111
  ```

- 为什么要使用原码, 反码和补码

  ```java
    2. 为什么java中byte的大小范围是-128 ~ 127?

    1. 首先在计算机中, 为了计算机运算设计的更简单, 符号位也参与计算, 其次计算机是只有加法没有减法的, 减法是用正数加负数来实现的。
    2. 如果我们分别使用原码, 反码和补码进行1+(-1)大小是8bit的计算:
              1                   1                 1               (-1)
    +       (-1)      +         (-1)    +         (-1)    +       (-127)
    ——————————————    ——————————————    ——————————————    ——————————————
    原码 0000 0001     反码 0000 0001     补码 0000 0001    补码 1111 1111
    原码 1000 0001     反码 1111 1110     补码 1111 1111    补码 1000 0001
    ——————————————    ——————————————    ——————————————    ——————————————
        1000 0010     反码  1111 1111    补码 10000 0000   补码 11000 0000
    ——————————————    ——————————————    ——————————————    ——————————————
              -2      原码  1000 0000    原码 0000 0000    原码  1000 0000
                      ——————————————    ——————————————    ——————————————
                                  -0                 0              -128

    3. 综合上面的结果, 原码的结果肯定是不对的, 反码的结果问题在于+0 & -0, 而补码的结果是正确的, 但是还有一个-0, 通过计算发现(-1) + (-127)的正常结果是-128, 而补码的计算结果是1000 0000, 所以我们-128的补码由1000 0000表示, 这样能够解决+0&-0的问题

    4. 这样也能解释为什么在java语言中, 基本数据类型byte的范围是[-2^(n-1), +2^(n-1)-1], 因为它们存储的时候是用补码, 程序运行展示的数据是原码的十进制。如果是使用反码表示, 范围就是[-2^(n-1)+1...-0, +0...+2^(n-1)-1]。这里有个特殊的类型: char, 因为它没有负数, 所以范围是[0, 2^16-1]
  ```

- java 中进制的表示

  ```java
    // 只有二进制有原码、反码和补码 定义基本数据类型的数据, 其大小不能超过默认大小, 比如byte -> 8bit
    System.out.println("--------------------------binary------------------------------------ ");
    // java中0b开头表示二进制
    byte a = 0b00000011;
    // 补码: 0 0000010 -> 反码: 0 0000010 -> 原码: 0 0000010 -> 十进制展示: 3
    System.out.println("positive binary: " + a);
    byte b = (byte) 0b10000001;
    // 补码: 1 0000001 -> 反码: 1 0000000 -> 原码: 1 1111111 -> 十进制展示: -127
    System.out.println("negative binary: " + b);

    System.out.println("---------------------------Octal------------------------------------ ");
    // 如果八进制存在大于8的数字肯定是不对的
    // 0000 0174 -> 001 111 100 -> 2^6 + 2^5 + 2^4 + 2^3 +2^2 -> 124
    byte c = 0174;
    System.out.println("positive Octal: " + c);

    System.out.println("---------------------------Hex------------------------------------ ");
    // 1f -> 0001 1111 -> 2^4 + 2^3 +2^2 + 2^1 + 2^0 -> 31
    byte d = 0x1f;
    System.out.println("positive hex: " + d);
  ```

### 负数的移位

`移位运算分为有符号移位和无符号移位, 分别用 << >> & <<< >>> 表示`

- 左移的时候, 无论是有符号还是无符号, 都是在低位补 0
- 右移的时候, 对于有符号整数, 采用的是`sar指令(算术移位: 高位补1)`. 对于无符号整数, 采用的是`shr指令(逻辑移位: 高位补0)`
- 在 java 语言中, 只有 <<, >>, >>> 三种, 使用 <<< 编辑器会报错
- 对照表

|                 | 左移         | 右移         | 符号    |
| --------------- | ------------ | ------------ | ------- |
| 有符号(算术 sa) | sal 低位补 0 | sar 高位补 1 | << >>   |
| 无符号(逻辑 sh) | shl 低位补 0 | shr 高位补 0 | <<< >>> |

```java
  System.out.println("------------------------正数移位------------------------");
  // 0000 0011 << 2 -> 0000 1100 -> 12
  byte e = 0b00000011 << 2;
  System.out.println("有符号位正数左移2位: " + e);

  // 0000 0111 >>  0000 0001 -> 1
  byte f = 0b00000111 >> 2;
  System.out.println("有符号位正数右移2位: " + f);

  // 0000 1111 >>> 0000 0001 -> 225
  byte g = 0b00001111 >>> 3;
  System.out.println("无符号位正数右移3位: " + g);

  System.out.println("-------------------------负数移位------------------------");

```
