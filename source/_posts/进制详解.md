---
title: 进制详解
toc: true
date: 2019-12-11 15:07:33
tags: Java
categories:
  - Java
thumbnail: https://img.vim-cn.com/f1/baa8d4b25d955cac1a4066c02761e0dd47097d.png
---

## 进制详解

`包括二进制、八进制、十进制和十六进制, 计算机由电路构成, 只有0/1两种状态, 所以采用的是二进制`

### 二进制

`由0 和 1组成, 计算机内部都是二进制的形式存储的。 进行加法运算的时候逢二进一, 减法运算的时候借一当二`

- 二进制加法

  <img src="https://img.vim-cn.com/ce/90614dbb397f2d74e43fa6018fda052dda0e30.png" title="图片来源: http://c.biancheng.net/">

- 二进制减法

  <img src="https://img.vim-cn.com/69/d84110b29955cfac1508d813f81403ea399440.png" title="图片来源: http://c.biancheng.net/">

### 十进制

`由0~9的数字组成, 加法计算时逢十进一, 减法计算时借一当十。十进制是人类发展中自然形成的`

<!--more-->

### 八进制

`由0~7的数字组成, 加法计算时逢八进一, 减法计算时借一当八。要求第一位是0开始`

- 八进制加法

  <img src="https://img.vim-cn.com/05/465d10e0da0f84f939352ae5f9f01b94ad5547.png" title="图片来源: http://c.biancheng.net/">

- 八进制减法

  <img src="https://img.vim-cn.com/44/f451f84706a30ea176b9fea7162d55fb413a65.png" title="图片来源: http://c.biancheng.net/">

### 十六进制

`由0~9,A(10),B(11),C(12),D(13),E(14),F(15)(不区分大小写)组成, 加法计算时逢十六进一, 减法计算时借一当十六。要求以0x开始`

- 十六进制加法

  <img src="https://img.vim-cn.com/bd/1c2e34b69cc0f9ce0d3a7ab8395ae721e20dc3.png" title="图片来源: http://c.biancheng.net/">

- 十六进制减法

  <img src="https://img.vim-cn.com/7c/57fa5cda003cb7d523df343ed909a30f86bd5b.png" title="图片来源: http://c.biancheng.net/">

## 进制互相换算

### 二进制 -> 十进制

假设一个二进制是 1011(3210), 从右往左开始分别是 0、1、2、3 位, 那么它的十进制值为:

```java
   1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 => 8 + 0 + 2 + 1 => 13
```

### 十进制 -> 二进制

假设一个十进制是 13, 一种方法是`除二反序取余法`, 计算如下:

```java
   13/2 = 6 余 1
   6/2 = 3 余 0
   3/2 = 1 余 1
   1/2 = 0 余 1
   反序取余数值, 结果是: 1101
```

另一种计算如下:

```java
 13 => 1*2^3 + 1*2^2 + 0*2^1 + 1*2^0
```

### 二进制 -> 八进制

假设一个二进制是 10110101, 从右往左每`三位`一组`(不足补 0, 二进制三位最大值是 7(111), 最小值是 0, 逢八进一, 这也是八进制的由来)`分别是:

```java
  010 110 101 对应的结果是: 010(2) 110(6) 101(5) => 265
```

### 二进制 -> 十六进制

假设一个二进制是 110110101, 从右往左每`四位`一组`(不足补 0, 二进制四位数最大值是 15(1111), 最小值是0, 逢十六进一， 也是十六进制的由来)`分别是:

```java
  0001 1011 0101 对应的结果是: 1 11(B) 5 => 1B5
```

## 位运算

### 与运算

`两个操作数都是1, 结果是1, 否则是0`

```java
  010100011
& 100011011
————————————
  000000011
```

### 或运算

`两个操作数有一个是1, 结果是1, 否则是0`

```java
  101001001
| 110000101
————————————
  111001101

```

### 异或

`两个操作数相同则为0, 不相同则为1`

```java
  101101011
^ 100100101
————————————
  001001110
```

### 取反运算

`对操作数取相反值`

```java
~ 010101110
————————————
  101010001
```

### 移位运算

`包括左移<< 和 右移 >>, 1 << 2 表示1左移2位, 1 >> 1 表示1右移1位`

```java
   101011001
<<         2
——————————————
   101100100

如果左移没有改变最高位(符号位), 那么将一个整数左移1位相当于乘以2, 编译器做移位比乘法快的多。

   101011001
>>         2
——————————————
   001010110

同理如果没有改变最高位, 那么右移一位相当于除以2
```

## 负数的二进制

### 负数的计算

`因为负数的二进制表达以及位运算的特殊性, 所以单独提出来解释, 负数的二进制是由其正值的补码(正值取反加1)形式展现的`

```java
以java中的int值为例子, int大小是4byte 32bit, 所以5的二进制值(原码)是:
0000 0000 0000 0000 0000 0000 0000 0101

那么5的反码就是位运算中的取反运算
~0000 0000 0000 0000 0000 0000 0000 0101
————————————————————————————————————————
 1111 1111 1111 1111 1111 1111 1111 1010

补码: 就是反码的基础上加上1
  1111 1111 1111 1111 1111 1111 1111 1010
+                                       1
—————————————————————————————————————————
  1111 1111 1111 1111 1111 1111 1111 1011

```

所以最终-5 的二进制值是: `1111 1111 1111 1111 1111 1111 1111 1011`

### 负数的移位

`移位运算分为有符号移位和无符号移位, 分别用 << >> & <<< >>> 表示`

- 左移的时候, 无论是有符号还是无符号, 都是在低位补 0
- 右移的时候, 对于有符号整数, 采用的是`sar指令(算术移位: 高位补1)`. 对于无符号整数, 采用的是`shr指令(逻辑移位: 高位补0)`
- 在 java 语言中, 只有 <<, >>, >>> 三种, 使用 <<< 编辑器会报错
- 对照表

|                 | 左移         | 右移         | 符号    |
| --------------- | ------------ | ------------ | ------- |
| 有符号(算术 sa) | sal 低位补 0 | sar 高位补 1 | << >>   |
| 无符号(逻辑 sh) | shl 低位补 0 | shr 高位补 0 | <<< >>> |
