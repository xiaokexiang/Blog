---
title: 多线程实战3
date: 2019-01-21 14:40:43
tags: Java
toc: true
categories:
  - 多线程
thumbnail: https://tvax1.sinaimg.cn/large/005BYqpggy1g4mghnm1y2j30sg0lcaan.jpg
---

## Immutable 模式

_想破坏也破坏不了_

```java
public class ThreadChapter1 {
    public static void main(String[] args) {
        Person person = new Person("lucky", "china");
        new PrintPersonThread(person).start();
        new PrintPersonThread(person).start();
        new PrintPersonThread(person).start();
    }
}

final class Person {
    private final String name;
    private final String address;

    public Person(String name, String address) {
        this.name = name;
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public String getaddress() {
        return address;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", address='" + address + '\'' +
                '}';
    }
}

class PrintPersonThread extends Thread {
    private Person person;

    PrintPersonThread(Person person) {
        this.person = person;
    }

    @Override
    public void run() {
        for(;;) {
            System.out.println(Thread.currentThread().getName() + "prints" + person);
        }
    }
}
```

<!-- more -->

## 思路拓展

- 实例创建之后，状态不再发生变化时
- 实例是共享的，且被频繁访问时
- String，Stringbuffer，StringBuilder

  - StringBuffer 是线程安全的，StringBuilder 是线程不安全的
  - StringBuilder 相比 StringBuffer 效率更高
  - 在单线程中字符串的频繁拼接 StringBuilder 效率更高，多线程使用 StringBuffer 则更安全；
  - 字符串简单操作时没必要使用上述两者，还是用 String 类型提高速度；

- String，BigInteger 以及所有的包装类都是 Immutable 不易变模式

- final 放在类上，该类无法扩展，final 在实例方法声明上，该方法不会被子类的方法重写，静态方法的声明上，该方法不会被子类的方法隐藏，final 也可以在局部变量上。

#### 关于 ArrayList 的线程安全问题

##### 非线程安全的 ArrayList 类

- <font color="red">当 ArrayList 被多个线程同时读写而失去安全性时，便会抛出 java.util.ConcurrentModificationException(执行并发修改了异常)</font>

```java
public class ThreadChapter2 {
    public static void main(String[] args) {
    List<Integer> list = new ArrayList<>();
    new WriteThread(list).start();
    new ReadThread(list).start();
    }
}

class WriteThread extends Thread {
    private final List<Integer> list;

    WriteThread(List<Integer> list) {
        super("WriteThread");
        this.list = list;
    }

    @Override
    public void run() {
        for (int i = 0; true; i++) {
            list.add(i);
            list.remove(0);
        }
    }
}

class ReadThread extends Thread {
    private final List<Integer> list;

    ReadThread(List<Integer> list) {
        super("ReadThread");
        this.list = list;
    }

    @Override
    public void run() {
        for (; ; ) {
            for (int n : list) {
                System.out.println(n);
            }
        }
    }
}

```

### 使用 synchronizedList 实现同步

```java
List<Integer> list = Collections.synchronizedList(new ArrayList<Integer>());
synchronized (list) {
     for (int n : list) {
          System.out.println(n);
     }
  }
```

### 使用 copy-on-write 类

_java.util.concurrent.CopyOnWriteArrayList_

- 写时复制，当集合执行写操作的时候，内部已确保安全的数组就整体复制，复制之后读取元素时就无需担心元素被修改了。<font color="red">但是每次写操作都会复制，耗费资源，如果是读操作多，推荐使用该方法</font>

```java
 CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();
```

### String.replace()

replace()方法会创建新的 String 实例，然后返回替换的值,实际返回的是替换后的新实例 t="CAT",但是如果替换前后的值一至，还是会返回 s。

```java
String s = "BAT";
s.replace("B","C");

```
