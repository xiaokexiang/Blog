---
title: JVM垃圾回收概念与算法
toc: true
tags: Java
categories:
  - Jvm
thumbnail: https://img.vim-cn.com/a3/1bd74b67fa66c7f1473f31da0dcddc21c342b7.png
---
## JVM 垃圾回收

### 垃圾回收概念
  1. 什么是垃圾? 特指在内存中、不会再被使用的对象。
  2. 什么是垃圾回收? "回收"相当于把垃圾"倒掉"，这样内存中就会有区域被腾出来。
  3. 为什么要回收? 如果不及时堆内存中的垃圾进行清理，这些垃圾对象所占的空间一直保留到应用程序结束，会导致被保留的空间无法被其他对象使用，从而导致OOM。
  
### 垃圾回收算法

- 引用计数法(Reference Counting)
  `对于一个对象A，只要有一个对象引用了A，那么A的计数器增加1，当引用失效的时候就减1`

  缺点: a. 无法解决循环引用，A引用B，B引用A，没有其他对象引用他们，那么会导致内存泄漏。 b. 在每次引用产生和消除的时候，伴随加法和减法的操作，对系统性能有影响。

- 标记清除法(Mark-Sweep)
  `分为`标记阶段`和`清除阶段`。在标记阶段，首先通过根节点标记所有从根节点开始的可达对象，未被标记的对象就是未被引用的垃圾对象。在清除阶段，清除所有未被标记的对象。`
  缺点:产生空间碎片。因为回收后的空间是不连续的，工作效率低于连续空间
  <!-- more -->

- 复制算法(Copying)
  `将原有的内存空间分为两块，每次只使用其中一块，在进行垃圾回收时，将正在使用的内存中的活对象复制到未使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。`
  优点: a. 通常新生代垃圾对象多余存活对象，所以使用复制算法效率高 b. 回收后的内存空间是没有碎片的
  缺点: 内存折半
  &emsp;`新生代串行垃圾回收器使用了该算法`: 分为eden、from(s0)和to(s1)，其流程: eden区和s0区的存活对象会被复制到s1区(如果是大对象或老年对象会直接进入老年代，如果s1区满了，对象也会进入老年代)，然后清空eden和s0区，然后将s0和s1区互相调换，保证s1永远是空的。

- 标记压缩算法(Mark-Compact)
  `从根节点开始，对所有可达对象做一次标记。在清除阶段，将所有的存活对象压缩到内存的一端，然后清除边界外的所有空间`
  优点: 避免了内存碎片的产生，不需要两块空间，效率高，是老年代的回收算法

- 分代算法(Generational Collecting)
  `它将内存区间根据对象的特点分成几块，根据每块内存区间的特点使用不同的回收算法，以提高回收的效率`
  &emsp;为了支持高频率的新生代回收，虚拟机可能使用一种叫做`卡表(Card table)`的数据结构。卡表为一个比特位集合，每一个比特位可以表示老年代的某个区域的所有对象是否持有新生代对象的引用，<font style="color: red">卡表位为0表示老年代区域没有任何对象指向新生代，为1表示老年代对象有指向新生代的应用。</font>在新生代GC的时候只需要扫描卡表位为1的老年代空间，有效提高回收效率。

- 分区算法(Region)
  `分区算法将整个堆空间分成连续的不同小区间，每个小区间都独立使用，独立回收`。优点: 控制一次回收小区间的数量，能够有效减少GC产生的停顿

- 主要垃圾回收算法图解

<img src="https://img.vim-cn.com/f0/c36e90fcb194544a1895722274d2b474556cf6.png">

### 判断可触及性
  //todo